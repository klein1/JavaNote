## 四种状态

无锁、偏向锁、轻量级锁、重量级锁

**锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。**

1. **减少锁持有时间**

只在有线程安全要求的程序上加锁，减少同步代码块对锁的持有时间。

2. **减小细粒度**

将单个耗时较多的锁操作拆分为多个耗时较少的锁操作，减少同一个锁上的竞争。提高偏向锁、轻量级锁的利用率。

3. **锁分离**

根据不同应用场景将锁的功能进行分离（读写锁）。

4. **锁粗化**

将关联性强的锁操作集中起来处理，避免锁分得太细时系统频繁地获取锁和释放锁，影响性能。

5. **锁消除**

虚拟机即时编译器在运行时，如果检测到某些共享数据不可能存在竞争，就执行锁消除。



### 乐观锁

每次读取数据时认为别人不会修改数据。通过 CAS 操作实现。



### 悲观锁

每次读取数据时认为别人会修改数据。基于 AQS 架构实现。



### 可重入锁

**也叫作递归锁**。在同一线程中，外层函数获取锁以后，内层的递归函数可以继续获取该锁。



### 偏向锁

**同一个锁被同一个线程多次获取的情况，消除线程锁重入的开销。**

轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量，而偏向锁在无竞争的情况下会把整个同步都消除掉。



### 轻量级锁

适用于线程交替执行同步代码块的情况（互斥操作），如果同一时刻有多个线程访问同一个锁，会导致轻量级膨胀为重量级锁。

如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。



### 重量级锁

基于操作系统互斥量实现，会导致进程在用户态与内核态之间切换。



### 分段锁

将数据分段，每个分段上单独加锁，把锁进一步细粒度化，提高并发效率。

**ConcurrentHashMap** 内部使用分段锁。



### 自旋锁

**持有锁的线程能够在很短的时间内释放资源**

 **为了让一个线程等一会，我们只需要让线程执行一个忙循环（自旋）**。

需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了。自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。

优点：减少 CPU 上下文切换

缺点：自旋时间太长，引起 CPU 资源浪费



### 死锁

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。