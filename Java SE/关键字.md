## this

1. 访问成员变量

2. 调用成员方法

3. 调用构造方法

   形式：**this([参数1,参数2…])**

   - 只能在构造方法中使用this调用其它的构造方法
   - 使用this调用构造方法的语句必须位于第一行，且只能出现一次
   - 不能在一个类的两个构造方法中使用this互相调用



## static

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名` `类名.静态方法名()`。
2. **静态代码块:** 静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次。
3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。



## super

1. 访问父类成员（成员变量、成员方法）

2. 调用父类的构造方法

   形式：**super([参数1,参数2…])**



## final

用于修饰类、变量和方法。

1. final修饰的类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法。
2. final修饰的方法不能被子类重写。
3. final修饰的变量（成员变量和局部变量）是常量，只能赋值一次。



## transient

阻止实例中用此关键字修饰的的变量序列化；

当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复；

transient 只能修饰变量，不能修饰类和方法。