## 自动内存管理

Java 的自动内存管理主要是针对**对象内存的回收**和**对象内存的分配**。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

#### 堆内存：

- **新生代 GC（Minor GC）**：占1/3堆空间，指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。
- **老年代 GC（Major GC）**：占2/3堆空间，指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。
- **永久代**：主要存放Class和Meta（元数据）信息。在Java 8中被元空间取代，直接使用操作系统的本地内存。



#### 新生代：

- **Eden**：8/10空间，新创建的对象首先存放在Eden区，如果属于大对象，则直接分配到老年代。

- **ServivorTo**：1/10空间，保留上一次MinorGC的幸存者。

- **ServivorFrom**：1/10空间，将上一次MinorGC的幸存者作为这一次MinorGC的被扫描者。



#### MinorGC（复制算法）：

- 对象都会首先在 Eden 区域分配，在一次MinorGC后，如果对象还存活，则会进入 ServivorTo，年龄加1，如果达到老年代的标准（默认15），则将其复制到老年代；如果ServivorTo内存不够，直接复制到老年代；如果对象属于大对象（2KB-128KB），也直接复制到老年代。

- 清空Eden和ServivorFrom中的对象。

- 将ServivorTo和ServivorFrom互换。



##### 对象优先在 eden 区分配

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

##### 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

为了避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率。

当老年代上的空间不足够存放，会发起一次 Major GC。

##### 长期存活的对象将进入老年代

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

##### 动态对象年龄判定

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。