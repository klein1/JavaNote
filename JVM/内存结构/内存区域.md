## 运行时数据区域

**线程私有：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)



### 程序计数器

**当前线程所执行的字节码的行号指示器。**

1. 字节码解释器通过改变程序计数器的值来依次读取指令，从而实现代码的流程控制，如：分支、循环、跳转、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，实现线程切换。

**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域**



### 虚拟机栈

**Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**

虚拟机栈由栈帧组成，每个栈帧包含：局部变量表、操作数栈、动态链接、方法出口。

每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：

1. return 语句
2. 抛出异常

**虚拟机栈会出现两种错误：**

- **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。

对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。

**8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。**



### 本地方法栈

**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。



### 堆

Java 虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域。



### 方法区

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。



### 运行时常量池

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）。

**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image.png](https://upload-images.jianshu.io/upload_images/9229344-b80df7e334408aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

